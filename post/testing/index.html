<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Software Testing - WYJ&#39;s Notes</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="author" content="">
    <meta name="keywords" content="">
    <link rel="canonical" href="https://w-yj.github.io/post/testing/">

    
    
    <link rel="stylesheet" type="text/css" href="https://w-yj.github.io/sass/pixyll.min.30e55e9fcc01694c576be315e114e0449103a0df1fb91cec0c2ada477ba30f6b.css">

    
    <link rel='stylesheet' type='text/css' href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' >
    <link rel='stylesheet' type='text/css' href='//fonts.googleapis.com/css?family=Lato:900,300'>
</head>

<body class="site">
    <div class="site-wrap">
        <header class="site-header px2 px-responsive">
    <div class="mt2 wrap">
        <div class="measure">
            <a href="https://w-yj.github.io" class="site-title">WYJ&#39;s Notes</a>
            <nav class="site-nav">
                
<div class="right">
<a href="https://w-yj.github.io/about/">About</a>
<a href="https://w-yj.github.io/tags/">Tags</a>
<a href="https://w-yj.github.io/contact/">Contact</a>
</div>
            </nav>
            <div class="clearfix"></div>
        </div>
    </div>
</header>

        <div class="post p2 p-responsive wrap" role="main">
            <div class="measure">
                
<div class="post-header mb2">
    <h1 class="py2">Software Testing</h1>
    <span class="post-meta">
        Mar 15, 2017
        
    </span>
    <br>
    
</div>
<article class="post-content">
    <h1 id="软件测试">软件测试</h1>
<!-- raw HTML omitted -->
<ul>
<li>Testing Intro
<ul>
<li>Bug and Pie model</li>
<li>Terminology</li>
<li>Level</li>
<li>Process</li>
</ul>
</li>
<li>White-Box Testing Method
<ul>
<li>Graph In Testing</li>
<li>Graph Coverage
<ul>
<li>Graph Coverage Criteria
<ul>
<li>Reach</li>
<li>Cover</li>
</ul>
</li>
<li>Test Criteria</li>
</ul>
</li>
<li>Structural Coverage
<ul>
<li>Vertex Coverage(VC)</li>
<li>Edge Coverage(EC)</li>
<li>Covering Multiple Edges</li>
<li>Subsume</li>
</ul>
</li>
<li>Control Flow Graph</li>
<li>DataFlow Coverage
<ul>
<li>Data Flow</li>
<li>Sets of Def and Use</li>
<li>DU Pair</li>
<li>Def-clear</li>
<li>DU Path</li>
</ul>
</li>
</ul>
</li>
<li>Black-Box Testing Method
<ul>
<li>Random Testing
<ul>
<li>Problem in RT</li>
<li>RT in security testing</li>
</ul>
</li>
<li>Adaptive Random Testing
<ul>
<li>近朱者赤近墨者黑</li>
<li>FSCS-ART algorithm</li>
<li>Problem in ART</li>
</ul>
</li>
<li>Anti-Random Testing</li>
<li>Equivalence Partition</li>
<li>Domain
<ul>
<li>Input domain</li>
<li>Partitioning Domains</li>
</ul>
</li>
<li>Two Approaches</li>
<li>Boundary-Value Ananysis</li>
<li>Combinatorial Testing</li>
<li>Selenium IDE</li>
<li>PICT</li>
</ul>
</li>
<li>Testing In Practice
<ul>
<li>Functional Testing</li>
<li>探索式测试</li>
</ul>
</li>
<li>Performance Testing
<ul>
<li>性能测试度量方法</li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="testing-intro">Testing Intro</h2>
<h3 id="bug-and-pie-model">Bug and Pie model</h3>
<p><strong>Bug - Fault, Error, Failure</strong></p>
<ul>
<li>Soft Fault: A <strong>static</strong> defect in the software, i.e. defect;</li>
<li>Software Error: An incorrect <strong>internal</strong> state that is the manifestation of some faults;</li>
<li>Software Failure: <strong>External</strong>, incorrect behavior with respect to the requirements or other description of the expected behaviour.</li>
</ul>
<p><strong>Pie Model</strong></p>
<ul>
<li>Execution/Reachability: The location or locations in the program that contain the fault must be reached</li>
<li>Infection: The stage of the program must be incorrect</li>
<li>Propagation: The infected state must prepagate to cause some input of the program to be incorrect.</li>
</ul>
<h3 id="terminology">Terminology</h3>
<ul>
<li>Test Case - Including Test Input(data), Test Oracle(Expected Output) and Others(Environment)</li>
<li>Debug vs Testing</li>
<li>Verification vs Validation
<ul>
<li>Validation: &ldquo;The assurance that a product, service, or a system meets the needs of the customer and other identified stakeholders. It often involves acceptance and suitability with external customers.&rdquo;</li>
<li>Verification: &ldquo;The evaluation of whether or not a product, service, or system compli es with a regulation, requirement, specification, or imposed condition. It is often an internal process.&rdquo;</li>
</ul>
</li>
<li>Static Testing vs Dynamic Testing
<ul>
<li>Static Testing without executing programs</li>
<li>Dynamic Testing with excuting programs</li>
</ul>
</li>
<li>Black-box Testing vs White-box Testing
<ul>
<li>Black-box Testing without source code</li>
<li>White-box Testing with source code</li>
<li>Gray-box Testing(通过反编译获得部分程序内部信息)</li>
</ul>
</li>
</ul>
<h3 id="level">Level</h3>
<blockquote>
<p>(Names are not standardized)</p>
</blockquote>
<ul>
<li>System testing</li>
<li>Integration testing</li>
<li>Module testing</li>
<li>Unit testing</li>
</ul>
<h3 id="process">Process</h3>
<p><img src="https://w-yj.github.io/img/Testing/TestingProcess.png" alt=""></p>
<h2 id="white-box-testing-method">White-Box Testing Method</h2>
<h3 id="graph-in-testing">Graph In Testing</h3>
<p>Multiple initial vertices V0={v1,v2}
增加一个哑结点V0={v0}
Multiple final vertices类似</p>
<p>Test Path: A path that starts at an initial vertex and ends at a final vertex. Test paths represent excution of test cases</p>
<ul>
<li>Some test paths can be excuted by many tests</li>
<li>Some test paths cannot be excuted by any tests</li>
</ul>
<p>Test and Test Path</p>
<ul>
<li>path(t): The test path excuted by test t</li>
<li>path(T): The set of test paths excuted by the set of tests T</li>
</ul>
<h3 id="graph-coverage">Graph Coverage</h3>
<ul>
<li>Structural Coverage</li>
<li>Defined on a graph just in terms of vertices and edges</li>
<li>Data Flow Coverage</li>
<li>Requires a graph to be annotated with reference to variables</li>
</ul>
<h4 id="graph-coverage-criteria">Graph Coverage Criteria</h4>
<h5 id="reach">Reach</h5>
<ul>
<li>Syntactic reach: A path exists in the graph</li>
<li>Semantic reach: A test exists that can excute that path</li>
</ul>
<h5 id="cover">Cover</h5>
<ul>
<li>A test path p covers a vertex v if v is in p</li>
<li>A test path p covers a edge e if e is in p</li>
<li>A test path p covers a subpath p&rsquo; if p&rsquo; is in p</li>
</ul>
<h4 id="test-criteria">Test Criteria</h4>
<ul>
<li>Test Requirement(TR): Descrin properties of test paths</li>
<li>Test Criterion: Rules that define test requirments</li>
<li>Satisfaction: Given a set TR of test requirement for criterion C, a set of tests T satisfies C on a graph if and only if for every test requirement in TR, there is a test path in path(T) that meets the test requirement tr</li>
</ul>
<h3 id="structural-coverage">Structural Coverage</h3>
<h4 id="vertex-coveragevc">Vertex Coverage(VC)</h4>
<ul>
<li>Test set T satisfies vertex coverage on graph G if and only if for every syntactically reachable vertex v in V，there is a path p in path(T) such that p covers v.</li>
<li>TR contains each reachable vertex in G.</li>
</ul>
<h4 id="edge-coverageec">Edge Coverage(EC)</h4>
<ul>
<li>Test set T satisfies edge coverage on graph G if for every syntactically reachable edge e in E, there is a path p in path(T) such that p covers e.</li>
<li>TR contains each reachable edge in G.
满足EC即满足VC，但是满足VC不一定满足EC。</li>
</ul>
<h4 id="covering-multiple-edges">Covering Multiple Edges</h4>
<ul>
<li>Edge-pair coverage requires pairs of edges.</li>
<li>Edge-Pair Coverage(EPC):
TR contains each reachable path of length to up 2, inclusive, in G.</li>
<li>Complete Path Coverage(CPC): TR contains all paths in G.</li>
<li>n-Path Coverage(nPC): TR contains each reachable path of length up to n, inclusive, in G.</li>
<li>VC(n=0), EC=(n=1), EPC(n=2), CPC(n=∞)</li>
</ul>
<h4 id="subsume">Subsume</h4>
<ul>
<li>C1 subsumes C2, denoted by C1 &gt;= C2;
For any T, if T satisfies C1 implies T satisfies C2.</li>
<li>n1PC &gt;= n2PC if n1&gt;=n2</li>
<li>C1 &gt;= C2 does not imply that T1 satisfying C1 can detect any fault detected by T2 which satisfies C2.</li>
</ul>
<p>i.e. EPC subsume EC subsume VC</p>
<h3 id="control-flow-graph">Control Flow Graph</h3>
<ul>
<li>A control flow graph(CFG) is a representation, using graph notation, of all paths that might be traversed through a problem during its excution. i.e. Vertex: statement, block, function, module Edge:  flow, jump, call</li>
<li>CFG: if, if-return(添加哑结点), while(添加一个额外节点)，do-while(也可以不添加额外节点，可以压缩表示)，for，break and continue, switch</li>
</ul>
<p><img src="https://w-yj.github.io/img/Testing/CFG_if.png" alt="CFG_if"></p>
<p><img src="https://w-yj.github.io/img/Testing/CFG_if-return.png" alt="CFG_if-return"></p>
<p><img src="https://w-yj.github.io/img/Testing/CFG_while.png" alt="CFG_while"></p>
<p><img src="https://w-yj.github.io/img/Testing/CFG_do-while.png" alt="CFG_do-while"></p>
<p><img src="https://w-yj.github.io/img/Testing/CFG_for.png" alt="CFG_for"></p>
<p><img src="https://w-yj.github.io/img/Testing/CFG_break_continue.png" alt="CFG_break_continue"></p>
<p><img src="https://w-yj.github.io/img/Testing/CFG_switch.png" alt="CFG_switch"></p>
<p><img src="https://w-yj.github.io/img/Testing/CFG.png" alt="CFG"></p>
<p>i.e. 使用<a href="http://sable.github.io/soot">soot</a>为java程序自动产生CFG</p>
<h3 id="dataflow-coverage">DataFlow Coverage</h3>
<h4 id="data-flow">Data Flow</h4>
<p>Beyond structure. Goal: Try to ensure that values are computed and used correctly.</p>
<p>数据流中关于变量的操作：</p>
<ul>
<li>Definition(def): A location where a value for variable is stored into memory.</li>
<li>Use: A location where a variable&rsquo;s value is accessed.</li>
</ul>
<p>i.e. The values given in defs should reach at least one, some, or all possible uses.</p>
<h4 id="sets-of-def-and-use">Sets of Def and Use</h4>
<ul>
<li>def(n) or def(e): The set of variables that are defines by node n or edge e.</li>
<li>use(n) or use(e): The set of variables that are used by node n or edge e.</li>
</ul>
<h4 id="du-pair">DU Pair</h4>
<ul>
<li>DU pair: A pair of location(li, lj) such that a variable v is defined at li and used at lj.</li>
</ul>
<h4 id="def-clear">Def-clear</h4>
<ul>
<li>Def-clear: A path from li to lj is def-clear with respect to variable v if v is not given another value on any of the nodes or edges in the path.</li>
<li>Reach: If there is a def-clear path frome li to lj with respect to v, the def of v at li reaches the use at lj.</li>
</ul>
<h4 id="du-path">DU Path</h4>
<ul>
<li>du-path: A simple subpath that is def-clear with respect to v from a def of v to a use of v.</li>
<li>du(ni, nj, v): the set of du-paths from ni to nj</li>
<li>du(ni, v): the set of du-paths that start at ni</li>
</ul>
<p><strong>三种定义流覆盖准则：</strong></p>
<ol>
<li>All-defs coverage(ADC): For each set of du-paths S = du(n, v), TR contains at least one path d in S.</li>
<li>All-users coverage(AUC): For each set of du-paths to uses S = du(ni, nj v), TR contains at least one path d in S.</li>
<li>All-du-paths coverage(ADUPC) For each set S = du(ni, nj, v), TR contains every path d in S.</li>
</ol>
<p><img src="https://w-yj.github.io/img/Testing/%E5%AE%9A%E4%B9%89%E6%B5%81%E8%A6%86%E7%9B%96%E5%87%86%E5%88%99.png" alt="定义流覆盖准则"></p>
<p><strong>e.g.</strong>
<img src="https://w-yj.github.io/img/Testing/%E6%95%B0%E6%8D%AE%E6%B5%81.png" alt="数据流"></p>
<p><img src="https://w-yj.github.io/img/Testing/%E6%95%B0%E6%8D%AE%E6%B5%812.png" alt="数据流2"></p>
<p><img src="https://w-yj.github.io/img/Testing/%E6%95%B0%E6%8D%AE%E6%B5%813.png" alt="数据流3"></p>
<h2 id="black-box-testing-method">Black-Box Testing Method</h2>
<h3 id="random-testing">Random Testing</h3>
<p>Test cases are generated purely at random[SWEBOK v3.0]</p>
<ul>
<li>Input domain must be known</li>
<li>Pick random points within input dommain</li>
<li>Automation</li>
</ul>
<h4 id="problem-in-rt">Problem in RT</h4>
<ul>
<li>Define input domain</li>
<li>Generate random sequence
<ul>
<li>Pseudo random sequence algorithm</li>
<li>Seed of pseudo random sequence algorithm</li>
<li>Randomness and Integrity Service(<a href="random.org">random.org</a>)</li>
</ul>
</li>
</ul>
<h4 id="rt-in-security-testing">RT in security testing</h4>
<p><strong>Fuzz testing(Fuzzing)</strong></p>
<ul>
<li>A special form of random testing, aims to breaking the software [SWEBOK v3.0]</li>
<li>Providing invalid, unexpected, or random data to the inputs of a program [wikipedia.org]</li>
</ul>
<h3 id="adaptive-random-testing">Adaptive Random Testing</h3>
<p><img src="https://w-yj.github.io/img/Testing/patterns.png" alt="patterns"></p>
<h4 id="近朱者赤近墨者黑">近朱者赤近墨者黑</h4>
<ul>
<li>A passed test, nearby tests may be passed</li>
<li>A failure test, nearby tests may be failed</li>
<li>Thus, selct test cases far away from others</li>
</ul>
<h4 id="fscs-art-algorithm">FSCS-ART algorithm</h4>
<blockquote>
<p>固定候选集的自适应随机测试算法</p>
</blockquote>
<pre><code>randomly generate an input t, run t, add t to T
while(stop criteria not reached)(寻找到一条错误或者测试资源耗尽)  
 randomly generate k candidate input c1, ...ck
 for each candidate ci
   compute min distance di to T
 end for
 select one candidate t with max distance
 run t, add t to T
end while
</code></pre><h4 id="problem-in-art">Problem in ART</h4>
<ul>
<li>Distance</li>
<li>Sampling</li>
<li>ART with enlarged input domain</li>
</ul>
<h3 id="anti-random-testing">Anti-Random Testing</h3>
<p><strong>Process:</strong></p>
<ul>
<li>Select one test case randomly</li>
<li>Select a test case with maximum Sum of Hamming Distance to existed test cases</li>
<li>Repeat</li>
</ul>
<h3 id="equivalence-partition">Equivalence Partition</h3>
<p><a href="http://www.cs.gmu.edu/~offutt/softwaretest/">PPT</a></p>
<ul>
<li>Can be equally applied at several levels of testing
<ul>
<li>Unit</li>
<li>Integration</li>
<li>System</li>
</ul>
</li>
<li>Relatively easy to apply with no automation</li>
<li>Easy to adjust the procedure to get more or fewer tests</li>
</ul>
<h3 id="domain">Domain</h3>
<h4 id="input-domain">Input domain</h4>
<ul>
<li>The input domain for a program contains all the possible inputs to that program</li>
<li>For even small program, the input domain is so large that it might as well be infinite</li>
<li>Testing is fundamentally about choosing finite sets of values from the input domain</li>
<li>Input parameters define the scope of the input domain
<ul>
<li>Parameters to a method</li>
<li>Data read from a file</li>
<li>Global variable</li>
<li>User level inputs</li>
</ul>
</li>
<li>Domain for each input parameter is partitioned into regions</li>
<li>At least one value is chosen from each region</li>
</ul>
<h4 id="partitioning-domains">Partitioning Domains</h4>
<ul>
<li>Domain D</li>
<li>Partition scheme p of D</li>
<li>The partition p defines a set of blocks, b1, b2, &hellip; bn</li>
<li>The partition must satisfy two properties
<ul>
<li>blocks must be pairwise disjoint(no overlap)</li>
<li>together the blocks cover the domain D(complete)</li>
</ul>
</li>
</ul>
<h3 id="two-approaches">Two Approaches</h3>
<p><strong>Interface-based approach</strong></p>
<ul>
<li>Develops chracteristics directly from individual input parameters</li>
<li>Simplest application</li>
<li>Can be partially automated in some situations</li>
</ul>
<p><strong>Functionality-based approach</strong></p>
<ul>
<li>Develops chracteristics from a behavioral view of the program under test</li>
<li>Harder to develop — requires more design effort</li>
<li>Harder to develop — requires more design effort</li>
<li>May result in better tests, or fewer tests that are as effective</li>
</ul>
<p><strong>Interface-Based Approach</strong></p>
<ul>
<li>Mechanically consider each parameter in isolation</li>
<li>This is an easy modeling technique and relies mostly on syntax</li>
<li>Ignores relationships among parameters</li>
</ul>
<p><strong>Functionality-Based Approach</strong></p>
<ul>
<li>Identify chracteristics that correspond to the intended functionality</li>
<li>Requires more design effort from tester</li>
<li>Can incorporate domain and semantic knowlege</li>
<li>Can use relationships among parameters</li>
</ul>
<h3 id="boundary-value-ananysis">Boundary-Value Ananysis</h3>
<p><strong>Select Boundary Values</strong></p>
<ul>
<li>An input variable with equivalent class[Min, Max]
Select: Min, Min+, Nom, Max-, Max</li>
<li>Select Boundary Values(Consider invalid values)
Select: Min-, Min, Min+, Nom, Max-, Max, Max+</li>
</ul>
<h3 id="combinatorial-testing">Combinatorial Testing</h3>
<ul>
<li>Fixed strength combinatorial testing
<ul>
<li>Pair-wise testing</li>
<li>T-way combinatorial testing</li>
</ul>
</li>
<li>Variable strength combinatorial testing</li>
</ul>
<p><strong>Key issue</strong></p>
<ul>
<li>Sampling in all combinations</li>
<li>Do not consider special information of inputs</li>
</ul>
<h3 id="selenium-ide">Selenium IDE</h3>
<h3 id="pict">PICT</h3>
<h2 id="testing-in-practice">Testing In Practice</h2>
<h3 id="functional-testing">Functional Testing</h3>
<p>根据产品特性和设计需求，验证一个产品的特性和行为是否满足设计需求</p>
<p><strong>功能测试常用步骤:</strong></p>
<ul>
<li>根据需求来细分功能点</li>
<li>根据功能点派生测试需求</li>
<li>根据测试需求设计测试用例</li>
<li>逐项执行功能测试用例验证产品</li>
</ul>
<p><strong>相关的测试类型:</strong></p>
<ul>
<li>正确性：产品功能是否与需求的设计文档一致</li>
<li>可靠性：用户交互是否引发软件崩溃和其他异常</li>
<li>易用性：软件产品完成特定任务的难易程度</li>
</ul>
<h3 id="探索式测试">探索式测试</h3>
<ul>
<li>一种软件测试风格</li>
<li>强调独立测试人员的个人自由和职责</li>
<li>将测试学习、设计、执行、结果、分析作为相互支持的活动</li>
<li>在整个项目之并行执行</li>
<li>强调关注价值和风险驱动</li>
</ul>
<p>此测试风格下的模型：启发式测试策略模型(Heuristic Test Strategy Model)</p>
<p><img src="https://w-yj.github.io/img/Testing/%E5%90%AF%E5%8F%91%E5%BC%8F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%9E%8B.png" alt="启发式策略模型"></p>
<p><strong>产品元素</strong>：需要测试的对象</p>
<ul>
<li>结构：产品的物理元素，如代码、硬件、配置文件、数据文件等。</li>
<li>功能：产品的功能</li>
<li>数据；产品所操作的数据</li>
<li>接口：产品所使用的或暴露出的接口</li>
<li>平台：产品所依赖的外部元素</li>
<li>操作：产品被使用的方式</li>
<li>时间：影响产品的时间因素</li>
</ul>
<p><strong>测程</strong></p>
<ul>
<li>任务：通过漫游测试，建立初始功能列表</li>
<li>潜在目标：学习软件功能，建立测试模型</li>
</ul>
<p><strong>功能列表的特征</strong></p>
<ul>
<li>建立了被测对象的整体模型</li>
<li>提供了可扩展的测试框架</li>
<li>提供了测试覆盖的目标</li>
<li>用简洁的形式提供丰富的信息</li>
</ul>
<p><strong>运用功能列表</strong></p>
<ul>
<li>将功能列表视作覆盖率指南，逐个检查每个功能</li>
<li>综合功能列表中的多个元素，来测试功能的协作</li>
</ul>
<h2 id="performance-testing">Performance Testing</h2>
<ul>
<li>验证产品的性能在特定负载和环境条件下使用是否满足性能指标</li>
<li>进一步发现系统中存在的性能瓶颈，优化系统</li>
</ul>
<h3 id="性能测试度量方法">性能测试度量方法</h3>
<ul>
<li>不同的关注对象采用不同的性能的度量方法</li>
<li>服务器端性能采用CPU、内存等使用率来度量</li>
<li>客户端性能通常根据系统处理特定用户请求的响应时间来度量</li>
</ul>

</article>


<p class="post-meta">
    Tags:&nbsp;
    
    
    <a href="https://w-yj.github.io/tags/Testing">Testing</a>
    
</p>



            </div>
        </div>
    </div>
    <footer class="center">
    <div class="p2 wrap">
        <div class="measure mt1 center">
            <small>
                Copyright &#169; 2017<br>
                Powered by <a href="http://gohugo.io/" target="_blank">Hugo</a> &amp; <a
                    href="https://github.com/azmelanar/hugo-theme-pixyll" target="_blank">Pixyll</a>
            </small>
        </div>
    </div>
</footer>

</body>
</html>